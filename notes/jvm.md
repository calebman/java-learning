#### 1. 类的生命周期

------

* 加载：查找并加载类的二进制数据
* 验证：确保被加载类的正确性
* 准备：为类的静态变量分配内存，并初始化为默认值
* 解析：符号引用转换为直接引用
* 初始化：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化 

#### 2. 内存结构

------

​	Java程序在运行时，需要在内存中的分配空间。为了提高运算效率，就对数据进行了不同空间的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。 

* 栈：存放局部变量
* 堆：存放所有创建出来的对象
* 方法区：被虚拟机加载的类信息、常量、静态常量等
* 程序计数器
* 本地方法栈

#### 3. GC

------

​	jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收**主要集中于 java 堆和方法区中**，在程序运行期间，这部分内存的分配和使用都是动态的.

> 判断对象存活

* 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，**无法解决对象相互循环引用**的问题。 
* 可达性分析：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。 

> 垃圾收集算法

* 标记-清楚算法
* 复制算法
* 标记-压缩算法
* 分代收集算法：把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。 